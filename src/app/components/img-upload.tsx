/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/E0KEHeSQKu7
 * Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
 */

/** Add fonts into your Next.js project:

 import { Inter } from 'next/font/google'

 inter({
 subsets: ['latin'],
 display: 'swap',
 })

 To read more about using these font, please visit the Next.js documentation:
 - App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
 - Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
 **/
'use client';
import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/app/components/ui/card';
import {Progress} from '@/app/components/ui/progress';
import {Button} from '@/app/components/ui/button';
import React, {Reducer, useCallback, useEffect, useReducer, useRef, useState} from 'react';
import axios from 'axios';
import {Input} from '@/app/components/ui/input';
import {useToast} from '@/app/components/ui/use-toast';
import FileDropZone from '@/app/components/file-drop-zone';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/app/components/ui/dropdown-menu';
import {cn} from "@/app/lib/utils";
import {ChevronDownIcon} from "@/app/components/icon/chevron-down-icon";
import {HtmlIcon} from "@/app/components/icon/html-icon";
import {MarkdownIcon} from "@/app/components/icon/markdown-icon";
import {BBCodeIcon} from "@/app/components/icon/bb-code-icon";
import {UrlIcon} from "@/app/components/icon/url-icon";
import {UploadIcon} from "@/app/components/icon/upload-icon";

type ImgUploadStatus = 'idle' | 'selected' | 'uploading' | 'completed'
type ImgUploadState = {
  status: ImgUploadStatus;
  file: File | null;
  fileKey: string;
  progress: number;
}
type ImgUploadAction = { type: 'idle' } | { type: 'selected'; file: File } | { type: 'uploading'; progress: number } | { type: 'completed'; fileKey: string } | { type: 'error'; error: string }
const uploadReducer: Reducer<ImgUploadState, ImgUploadAction> = (state, action) => {
  switch (action.type) {
    case 'idle':
      return { ...state, status: 'idle', file: null, fileKey: '', progress: 0 };
    case 'selected':
      return { ...state, status: 'selected', file: action.file, fileKey: '', progress: 0 };
    case 'uploading':
      return { ...state, status: 'uploading', progress: action.progress };
    case 'completed':
      return { ...state, status: 'completed', fileKey: action.fileKey, progress: 100 };
    case 'error':
      return { ...state, status: 'selected', fileKey: '', progress: 0 };
  }
}

const initialState: ImgUploadState = { status: 'idle', file: null, fileKey: '', progress: 0 };

export function ImgUpload() {
  const [{ status, file, fileKey, progress }, dispatch] = useReducer(uploadReducer, initialState);

  const [copyLink, setCopyLink] = useState('');

  const { toast } = useToast();

  const filePath = fileKey && /file/ + fileKey;
  const fileUrl = filePath && new URL(filePath, document.baseURI).href;

  const handleFileChange = (file: File) => {
    dispatch({ type: 'selected', file })
  };

  const handleCopyUrl = async () => {
    if (copyLink) {
      await navigator.clipboard.writeText(copyLink);
      toast({
        description: ' 🎉 Copied URL to clipboard.',
      });
    }
  };

  const handleUpload = async () => {
    if (!file) {
      toast({
        variant: 'destructive',
        title: 'No file selected.',
      });
      return;
    }

    const formData = new FormData();
    formData.append('file', file);

    try {
      dispatch({ type: 'uploading', progress: 0 });
      const response = await axios.post('/api/upload', formData, {
        onUploadProgress: function(progressEvent) {
          if (progressEvent.lengthComputable && progressEvent.total) {
            const percentComplete = Math.floor((progressEvent.loaded / progressEvent.total) * 100);
            dispatch({ type: 'uploading', progress: percentComplete });
          }
        },
      });

      const data = response.data;
      dispatch({ type: 'completed', fileKey: data.key });
      toast({
        description: ' 👏 Upload completed.',
      });
    } catch (e: any) {
      const error = e.response?.data?.message || 'Upload failed.';
      dispatch({ type: 'error', error })
      toast({
        variant: 'destructive',
        title: error,
      });
    }
  };

  const handleSubmit = async () => {
    if (fileKey) {
      await handleCopyUrl();
    } else {
      await handleUpload();
    }
  };

  const uploading = status === 'uploading';
  const buttonText = status === 'completed' ? '✨ Copy to Clipboard ✨' : (uploading ? 'Uploading...' : 'Submit');
  const sProgress = (uploading && progress > 95) ? 95 : progress;

  return (
    <div className="relative w-full max-w-md mx-auto">
      {/*<div className="absolute inset-0 bg-gradient-to-r from-[#e0f2fe] to-[#bae6fd] opacity-20 blur-xl" />*/}
      <Card className="z-10 bg-white bg-opacity-40 rounded-none border-0 shadow-none sm:rounded-xl sm:border sm:shadow">
        <CardHeader>
          <CardTitle>Upload Images</CardTitle>
          <CardDescription>Drag and drop your images here or click to select files.</CardDescription>
        </CardHeader>
        <CardContent className="grid gap-4">
          <FileZone
              disabled={uploading}
              onFileChange={handleFileChange}
              file={file}
              className="flex flex-col items-center justify-center h-40 border-2 border-dashed border-muted rounded-lg cursor-pointer"
          />
          <Progress value={sProgress} />
          <LinkCopyBox link={fileUrl} filename={file?.name} onChange={setCopyLink} />
          <Button type="button" disabled={uploading} variant={!fileKey ? 'default' : 'success'} onClick={handleSubmit}
                  className="w-full">
            {buttonText}
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}

function FileZone({ disabled, onFileChange, className, file }: { disabled: boolean, onFileChange: (file: File) => void, className?: string, file: File | null }) {
  const inputFileRef = useRef<HTMLInputElement | null>(null);
  const [previewUrl, setPreviewUrl] = useState('');

  const { toast } = useToast();

  useEffect(() => {
    setPreviewUrl('');
    if(file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreviewUrl(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  }, [file, setPreviewUrl]);

  const fileChange = useCallback((file: File) => {
    if(disabled) {
      return;
    }
    const maxSize = 5 * 1024 * 1024;
    if(file.size > maxSize) {
      toast({
        variant: 'destructive',
        title: 'File size exceeds 5MB.',
      });
      return;
    }
    onFileChange && onFileChange(file)
  }, [disabled, onFileChange, toast]);

  useEffect(() => {
    const handlePaste = (event: ClipboardEvent) => {
      const items = event.clipboardData?.items;
      if(!items || items.length === 0) {
        return;
      }

      const item = items[0];
      if(item.kind !== 'file') {
        toast({
          variant: 'destructive',
          title: 'Only JPG, PNG, and GIF images are supported.',
        });
        return;
      }

      const file = item.getAsFile();
      if(!file || (file.type !== 'image/png' && file.type !== 'image/jpeg' && file.type !== 'image/gif')) {
        toast({
          variant: 'destructive',
          title: 'Only JPG, PNG, and GIF images are supported.',
        });
        return;
      }
      fileChange(file);
    }

    window.addEventListener('paste', handlePaste);
    return () => window.removeEventListener('paste', handlePaste);
  }, [fileChange, toast]);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length) {
      const file = e.target.files![0];
      fileChange(file);
    }
  };

  const handleFileDrop = (files: FileList) => {
    fileChange(files[0]);
  };

  return (
      <FileDropZone
          className={cn(className, disabled ? ' opacity-50 pointer-events-none' : '')}
          onClick={() => inputFileRef.current?.click()}
          onFileDrop={handleFileDrop}
          aria-disabled={disabled}
          accept=".jpg,.jpeg,.png,.gif"
      >
        <input className="hidden" ref={inputFileRef} disabled={disabled} type="file" accept=".jpg,.jpeg,.png,.gif"
               onChange={handleFileChange} />
        {previewUrl ? (
            <div>
              {/* eslint-disable-next-line @next/next/no-img-element */}
              <img src={previewUrl} className={'max-h-36 rounded'} alt="Preview" />
            </div>
        ) : (
            <>
              <UploadIcon className="w-8 h-8 text-muted-foreground" />
              <p className="mt-2 text-sm text-muted-foreground">Click to select files</p>
            </>
        )}

      </FileDropZone>
  )
}

type LinkType = 'url' | 'html' | 'markdown' | 'bbCode'

function LinkCopyBox({ link, filename, onChange }: {
  link: string,
  filename?: string,
  onChange?: (value: string) => void
}) {
  const inputRef = useRef<HTMLInputElement>(null);
  const [type, setType] = useState<LinkType>('url');
  const [copyLink, setCopyLink] = useState(getLink(type, link, filename || 'image'));

  useEffect(() => {
    setCopyLink(getLink(type, link, filename || 'image'));
  }, [type, link, filename]);

  useEffect(() => {
    if (onChange) {
      onChange(copyLink);
    }
  }, [copyLink, onChange]);
  const handleInputFocus = () => {
    if (inputRef.current) {
      inputRef.current.select();
    }
  };
  const handleTypeChange = (value: LinkType) => {
    return () => {
      setType(value);
    };
  };

  return (
    <div className="flex items-center gap-2">
      <Input type="text" disabled={!link} placeholder="Image URL" ref={inputRef} className="flex-1"
             onFocus={handleInputFocus} value={copyLink} readOnly />
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button type="button" variant="outline"
                  className={'pr-2 pl-3 bg-transparent text-muted-foreground focus-visible:ring-0 hover:bg-transparent'}>
            <CodeIcon type={type} className={'h-4 w-4 mr-1'} />
            <ChevronDownIcon className="h-4 w-4 text-gray-400" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem onSelect={handleTypeChange('url')}>
            <UrlIcon className="h-4 w-4 mr-1.5" /> URL
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={handleTypeChange('markdown')}>
            <MarkdownIcon className="h-4 w-4 mr-1.5" /> Markdown
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={handleTypeChange('html')}>
            <HtmlIcon className="h-4 w-4 mr-1.5" /> HTML
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={handleTypeChange('bbCode')}>
            <BBCodeIcon className="h-4 w-4 mr-1.5" /> BBCode
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}

function getLink(type: LinkType, link: string, filename: string) {
  switch (type) {
    case 'url':
      return link;
    case 'html':
      return `<img src="${link}" alt="${filename}" />`;
    case 'bbCode':
      return `[img]${link}[/img]`;
    case'markdown':
      return `![${filename}](${link})`;
    default:
      return link;
  }
}

function CodeIcon({ type, className }: { type: LinkType, className?: string }) {
  switch (type) {
    case 'url':
      return <UrlIcon className={className} />;
    case 'html':
      return <HtmlIcon className={className} />;
    case 'bbCode':
      return <BBCodeIcon className={className} />;
    case'markdown':
      return <MarkdownIcon className={className} />;
    default:
      return <UrlIcon className={className} />;
  }
}

